## 多线程并发拓展
1. 死锁
    - 死锁发生的必要条件
        1. 互斥条件
        进程对所分配资源进行排他性使用，即在一段时间内，某个资源只能被一个进程占用。如果此时其他进程请求该资源，则请求进程只能等待，直到占有该资源的进程用毕释放
        
        2. 请求和保持条件
        进程至少保持了一个资源，但又提出了新的资源请求，而其他资源被其他进程占用，此时进程被阻塞，但对自己已获得的资源保持不放
        
        3. 不可抢占条件
        进程已获得资源在未使用前不能被抢占，只能在进程使用完时自己释放
        
        4. 循环等待条件
        在发生死锁时，必然存在一个*进程-资源*的循环链。即进程集合{p0,p1,p2,p3...,pn}中的p0在等待一个p1占用的资源，p1在等待p2占用的资源.... pn在等待p0占用的资源
2. 多线程并发最佳实践
    - 使用本地变量：多使用本地变量而不是创建一个类或者创建一个对象
    - 使用不可变类：例如String    
    - 最小化锁的作用域范围：S=1/(1-a+a/n) a代表并行计算部分所占的比例，n代表并行处理的节点个数，S代表加锁比；当a = 1时，只有串行没有并行，加锁比等于n；
    - 使用线程池的Executor，而不是直接new Thread执行；
    - 宁可使用同步也不要使用线程的wait和notify，应该优先使用线程的同步工具CountDownLatch，Semaphore等，使用BlockingQueue实现生产消费的设计比使用wait和notify要好；
    - 使用Blocking Queue实现生产消费模式；
    - 使用并发结合而不是加了锁的同步集合；
    - 使用Semaphore创建有界的访问；
    - 宁可使用同步代码块，也不使用同步的方法；
    - 避免使用静态变量，如果必须用，尽量把其变成final的，如果是集合的话，可以让其变成只读结合；

3. Spring与线程安全

   **Spring bean**
   
    [（转）Spring的线程安全](https://blog.csdn.net/csdnlijingran/article/details/83094756)
    - Spring对每个bean提供了一个scope属性来表示该bean的作用域。它是bean的生命周期。例如，一个scope为singleton的bean，在第一次被注入时，会创建为一个单例对象，该对象会一直被复用到应用结束。
      
        - singleton：默认的scope，每个scope为singleton的bean都会被定义为一个单例对象，该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。在整个Spring IoC容器里，只有一个bean实例，所有线程共享该实例。
    
        - prototype：bean被定义为在每次注入时都会创建一个新的对象。每次请求都会创建并返回一个新的实例，所有线程都有单独的实例使用，这种方式是比较安全的，但会消耗大量内存和计算资源。
        - request（请求范围实例）：bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。每当接受到一个HTTP请求时，就分配一个唯一实例，这个实例在整个请求周期都是唯一的。
        - session（会话范围实例）：bean被定义为在一个session的生命周期内创建一个单例对象。在每个用户会话周期内，分配一个实例，这个实例在整个会话周期都是唯一的，所有同一会话范围的请求都会共享该实例。
        - application：bean被定义为在ServletContext的生命周期中复用一个单例对象。
        - websocket：bean被定义为在websocket的生命周期中复用一个单例对象。
        - globalsession（全局会话范围实例）：这与会话范围实例大部分情况是一样的，只是在使用到portlet时，由于每个portlet都有自己的会话，如果一个页面中有多个portlet而需要共享一个bean时，才会用到。
        - 我们交由Spring管理的大多数对象其实都是一些无状态的对象，这种不会因为多线程而导致状态被破坏的对象很适合Spring的默认scope，每个单例的无状态对象都是线程安全的（也可以说只要是无状态的对象，不管单例多例都是线程安全的，不过单例毕竟节省了不断创建对象与GC的开销）。
    - 无状态对象
    
        - 无状态的对象即是自身没有状态的对象，自然也就不会因为多个线程的交替调度而破坏自身状态导致线程安全问题。无状态对象包括我们经常使用的DO、DTO、VO这些只作为数据的实体模型的贫血对象，还有Service、DAO和Controller，这些对象并没有自己的状态，它们只是用来执行某些操作的。例如，每个DAO提供的函数都只是对数据库的CRUD，而且每个数据库Connection都作为函数的局部变量（局部变量是在用户栈中的，而且用户栈本身就是线程私有的内存区域，所以不存在线程安全问题），用完即关（或交还给连接池）。
        
        - Controller默认是单例的，一个HTTP请求是会被多个线程执行的，这就又回到了线程的安全问题。当然，你也可以把Controller的scope改成prototype，实际上Struts2就是这么做的，但有一点要注意，Spring MVC对请求的拦截粒度是基于每个方法的，而Struts2是基于每个类的，所以把Controller设为多例将会频繁的创建与回收对象，严重影响到了性能。
       
4. HashMap与ConcurrentHashMap
    
    [HashMap、HashTable与ConcurrentHashMap的不同](https://www.cnblogs.com/heyonggang/p/9112731.html)
    
    - HashMap
       
       [HashMap为什么不是线程安全](https://www.zhyocean.cn/article/1553946904)
       - 底层数组+链表实现，可以存储null键和null值，线程不安全
       - 初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂
       - 扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入
       - 插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）
       - 当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀
       - 计算index方法：index = hash & (tab.length – 1)
       
       ![HashMap扩容](../pic/HashMap.png)
       
       - HashMap的初始值还要考虑加载因子 
         
          哈希冲突：若干Key的哈希值按数组大小取模后，如果落在同一个数组下标上，将组成一条Entry链，对Key的查找需要遍历Entry链上的每个元素执行equals()比较。
         
          加载因子：为了降低哈希冲突的概率，默认当HashMap中的键值对达到数组大小的75%时，即会触发扩容。因此，如果预估容量是100，即需要设定100/0.75＝134的数组大小。
         
          空间换时间：如果希望加快Key查找的时间，还可以进一步降低加载因子，加大初始大小，以降低哈希冲突的概率。    
          
    - CurrentHashMap
        
        - 底层采用分段的数组+链表实现，线程安全
        
        - 通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)
        - Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术
        - 有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁
        - 扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容