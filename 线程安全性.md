## 线程安全性

- df: 当多个线程访问某个类时，不管运行时环境采用**何种调度方式**或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么称这个类是线程安全的
    
    - 原子性：提供了互斥访问，**同一时刻只能有一个线程来对他进行操作**
    - 可见性：一个线程对主内存的修改可以及时的被线程观察到
    - 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序
    
   1. 原子性 -Atomic包
        
        - AtomicXXX: CAS,Unsafe.compareAndSwapInt
        
        ```java
           // Java底层包、非Java实现
           public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
        
           // 拿当前对象的值和底层的值进行对比，如果相等才进行操作，如果不同则一直执行，直到相同
           public final int getAndAddInt(Object var1, long var2, int var4) {
             int var5;
                  do {
                      var5 = this.getIntVolatile(var1, var2);
                  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
          
                  return var5;
              }
        
        ```
      - AtomicLong,LongAdder
        - LongAdder: AtomicLong的实现原理是：利用底层操作系统的CAS来保证原子性，在一个死循环内不断执行CAS操作，直到操作成功。不过，CAS操作的一个问题是在并发量比较大的时候，可能很多次的执行CAS操作都不成功，这样性能就受到较大影响。 
                     在ConcurrentHashMap中，对Map分割成多个segment，这样多个Segment的操作就可以并行执行，从而可以提高性能。在JDK8中，LongAdder与ConcurrentHashMap类似，将内部操作数据value分离成一个Cell数组，每个线程访问时，通过Hash等算法映射到其中一个Cell上。 
                     计算最终的数据结果，则是各个Cell数组的累计求和。
        - 缺点：在统计时如果有并发可能会导致统计的数据有所误差
      - AtomicReference,AtomicReferenceFieldUpdater
        - AtomicExample5
      - AtomicStampReference: CAS的ABA问题     
        - ABA问题：在进行CAS操作时，线程将A改为B又改回A,每次修改时改变**版本号**
   
   2. 原子性-synchronized
      - 修饰代码块：大括号括起来的代码，作用于调用的对象
      - 修饰方法：整个方法，作用于调用的对象
      - 修饰静态方法：整个静态方法，作用于所有对象
      - 修饰类：括号括起来的部分，作用于整个对象
      - 与lock的对比
        - synchronized：不可中断锁，适合竞争不激烈，可读性好
        - Lock：可中断锁，多样化同步，竞争激烈时能维持常态
        - Atomic：竞争激烈时能维持常态，比Lock性能要好；但只能同步一个值
   
   3. 可见性
     > 导致共享变量在线程间不可见的原因
     - 线程交叉执行
     - 重排序结合线程交叉执行
     - 共享变量更新后的值没有在工作内存与主存间及时更新
        1.  JVM关于synchronized的两
